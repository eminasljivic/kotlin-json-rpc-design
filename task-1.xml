<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc>

<rfc xmlns:xi="http://www.w3.org/2001/XInclude"
     category="std"
     docName="kotlin-json-rpc-design"
     ipr="none"
     consensus="true"
     submissionType="IETF">
<front>
    <title>Kotlin JSON-RPC 2.0 Design</title>
    <author initials="E." surname="Sljivic">
    </author>
    <date day="11" month="January" year="2026"/>
    <abstract>
      <t>
        This document describes the design for the JSON-RPC 2.0 for the kotlinx-rpc.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Overview" anchor="overview">
      <t>
        This document describes a Kotlin model and client/server API for JSON-RPC 2.0. The goal is to create a light weight design without any code generation needed.
      </t>

      <t>
        Transport mechanisms, authentication, and specific behavior are intentionally excluded and left to higher-level implementations.
      </t>
    </section>

    <section title="Conventions" anchor="conventions">
      <t>
        The key words "MUST", "MUST NOT", "SHOULD", "SHOULD NOT", and "MAY" in this document are to be interpreted as described in RFC 2119.
      </t>
    </section>

    <section title="JSON-RPC"> 
      <section title="2.0">
        
      </section>
    </section>

    <section title="Serialization Strategy" anchor="serialization">
      <t>
        Implementation SHOULD use the core library kotlinx.serialization, as it is part of the core libraries and is well-tested and reliable.
      </t>

      <t>
        It also provides classes such as JsonElement or JsonPrimitive, which allow for the variable structures of JSON objects while still enabling easy serialization/deserialization.
      </t>

      <t>
        All examples in this document assume the use of kotlinx.serialization. Alternative serialization frameworks may be used at the implementer's discretion.
      </t>
    </section>

    <section title="Core Data Model" anchor="core-data-model">
      <section title="Base Message Model" anchor="base-message-model">
        <sourcecode type="kotlin">
sealed interface JsonRpcObject {
    val jsonrpc: String?
}
        </sourcecode>

        <t>
          Because JSON-RPC 2.0 enforces a strict structure and a closed set of types for RPC calls, a sealed interface was used to restrict subclass declarations to the same module. The interface defines the jsonrpc property, which is mandatory for all JSON-RPC 2.0 objects, but sets it as nullable to allow its use with 1.0. For more information, refer to Section <xref target="compatibility">Backward Compatibility</xref>.
        </t>

        <t>
          To maintain this restriction, the interface is implemented using data classes only, as they are final by default.
        </t>
      </section>

      <section title="Request &amp; Notification" anchor="request-notification">
           <sourcecode type="kotlin">
data class JsonRpcRequest (
  override val jsonrpc: String?,
  val method: String,
  val params: JsonElement? = null,
  val id: JsonPrimitive? = null
) : JsonRpcObject
        </sourcecode>

        <t>
          Since Section 4 of <xref target="JSON-RPC-2.0">JSON-RPC 2.0</xref> defines the id field to be either a string or a number, implementations MUST represent it as a JsonPrimitive. This is possible because the id is not otherwise accessed and is passed through unchanged in the response. Because JsonPrimitive also allows boolean values and special null values, implementations MUST perform validations during the initialization of the object to ensure that only strings or numbers are accepted.
        </t>

        <t>
          As defined in Section 4.1 of the <xref target="JSON-RPC-2.0">JSON-RPC 2.0</xref>, the difference between a request and a notification is the existence of the id. This is modeled by making the id property nullable, while enforcing the correct usage through higher-level APIs. The option to have a separate class for notifications was considered. See Section <xref target="notification-handling">Notification Handling</xref>.
        </t>

        <t>
          According to the specification, parameters MAY be passed either by position or by name, corresponding to a JSON array or object, respectively. To support both forms, parameters are represented using JsonElement. Again, validations are applied to ensure that only JsonObject and JsonArray values are accepted, as primitive values are not valid parameters. The idea of using stronger types for the parameters was considered; see Section <xref target="request-parameter-type">Request Parameter Type</xref>.
        </t>
      </section>

      <section title="Response" anchor="response">
        <sourcecode type="kotlin">
data class JsonRpcResponse (
  override val jsonrpc: String?,
  val result: JsonElement? = null,
  val error: JsonRpcError? = null,
  val id: JsonPrimitive? = null
) : JsonRpcObject
        </sourcecode>

        <t>
          The result property MUST be represented as a JsonElement whose value is server-defined. 
        </t>

        <t>
          As defined in Section 5 of <xref target="JSON-RPC-2.0">JSON-RPC 2.0</xref>, either the result or error property MUST be exclusively set. This MUST be validated at initialization as well.
        </t>
      </section>

      <section title="Error Model" anchor="error-model">
        <sourcecode type="kotlin">
data class JsonRpcError (
    val code: Long,
    val message: String,
    val data: JsonElement? = null
)
        </sourcecode>

        <t>
          The error code is represented as a Long, since the code MUST be an integer as defined in Section 5.1 of <xref target="JSON-RPC-2.0">JSON-RPC 2.0</xref>. Using Long accommodates the full integer range representable by a JSON number, as defined in [RFC8259].
        </t>

        <t>
          The JsonElement was used to allow both primitive and structured values for the data property and was made nullable, as defined in Section 5.1 of <xref target="JSON-RPC-2.0">JSON-RPC 2.0</xref>.
        </t>
      </section>

      <section title="Validations" anchor="validations">
        <t>
          Structural specifications that apply to RPC objects are validated during object initialization. Context-dependent validations, such as request/response correlation or result/response semantics, are enforced at higher protocol layers.
        </t>
      </section>
    </section>

    <section title="Client API Design" anchor="client-api">
      <sourcecode type="kotlin">
interface JsonRpcClient {
  fun &lt;T&gt; request(
    method: String, 
    parameters: JsonElement? = null, 
    id: JsonPrimitive? = null,
    serializer: KSerializer&lt;T&gt;
  ): T

  fun notify(
    method: String, 
    parameters: JsonElement? = null
  )
}
      </sourcecode>

      <t>
        The client SHOULD expose two distinct methods: one for JSON-RPC requests and one for JSON-RPC notifications. This separation provides a clear distinction between request and notification semantics, thereby avoiding the need for additional runtime checks to differentiate between RPC call types.
      </t>

      <t>
        Each method SHOULD expose all possible properties of the respective RPC call type.
      </t>

      <t>
        A notification MUST NOT include the id property. If an id is exposed, it MUST be ignored. This could occur if a JsonRpcRequest object were passed directly instead of passing the properties as separate parameters. This design option was also considered. See Section <xref target="client-method-parameters">Client Method Parameters</xref>.
      </t>

      <section title="Request Method" anchor="request-method">
        <t>
          The id parameter SHOULD be nullable, as the id SHOULD NOT be used for direct logic and MAY be generated by the request method. To allow user-defined logic, the id MAY be explicitly provided by the user.
        </t>

        <t>
          The request method MAY omit the id parameter and manage request identifiers internally.
        </t>

        <t>
          The method SHOULD return the expected generic type directly and therefore SHOULD accept a KSerializer capable of deserializing the result property. This allows the user to work directly with the result object without requiring additional logic. Since the user does not have access to the error object, the method MUST propagate errors to the caller.
        </t>
      </section>
    </section>

    <section title="Server API Design" anchor="server-api">
      <sourcecode type="kotlin">
interface JsonRpcServer {
  inline fun &lt;reified R&gt; register(
    method: String,
    resultSerializer: KSerializer&lt;R&gt;,
    metadata: RpcMetaData,
    noinline handler: suspend (List&lt;out Any?&gt;) -&gt; R
  )

  method fun registerNotification(
    method: String,
    metadata: RpcMetaData,
    handler: suspend (List&lt;out Any?&gt;) -&gt; Unit
  )

  fun receiveRpcCall(
    request: JsonRpcRequest
  ): JsonRpcResponse?
}
      </sourcecode>

      <section title="Register Functions">
      <t>
        The server SHOULD have two registration functions to differentiate between requests and notifications. Since the notification lambda function SHOULD NOT return a result. With that, no serializer for the result is needed.
      </t>

      <t>
        To ensure multiplatform compatibility, a serializer for the result MUST be provided as an explicit parameter. The same requirement applies to method parameters, for which the ParameterMetaData MUST include a corresponding deserializer.
      </t>
      </section>

      <section title="Parameters">

      <sourcecode type="kotlin">
data class ParameterMetaData&lt;T&gt;(
  val name: String,
  val serializer: KSerializer&lt;T&gt;,
  val isOptional: Boolean = false
)

data class RpcMetaData {
  parameterNames: List&lt;ParameterMetaData&gt;
}
      </sourcecode>

      <t>
        To support a variable number and variety of parameters, a handler method SHOULD declare a single parameter of type List&lt;out Any?&gt;. Since request parameters are represented as a JsonElement, they MUST first be converted into a List.
      </t>

      <t>
        For a JsonArray, this mapping is direct and requires no additional processing. For a JsonObject, the mapping is more complex, as object properties MUST be associated with specific list indices. To enable this association, additional metadata MUST be provided by the handler.
      </t>

      <t>
        The RpcMetaData object therefore MUST include a List describing the parameters, which is used to map object properties to their corresponding list indices. This list MUST be validated to only contain non-empty distinct parameter names.
      </t>
      </section>

      <section title="Call Handling">
      <t>
        The server MUST implement a method that receives the RPC calls and then calls the corresponding method. The method MUST validate the received RPC call before handing it over to the handler.
      </t>

      <t>
        The receiveRpcCall method MUST validate all possible errors mentioned in Section 5.1 of <xref target="JSON-RPC-2.0">JSON-RPC 2.0</xref>.
      </t>

      <t>
       The receiveRpcCall method MUST locate the target method using the registered method name and invoke it via the corresponding handler with the deserialized parameters.
      </t>

      <t>
        When handling a request, a JsonRpcResult object MUST be created and returned. If the call succeeds, this object MUST contain the serialized result using the resultSerializer. If an error occurs, it MUST instead contain a JsonRpcError describing the failure.
      </t>
      </section>
    </section>

    <section title="Batch Requests" anchor="batch-requests">
      <t>
        To accommodate batch requests, the client API MUST be extended with a method that accepts a List &lt; JsonRpcRequest&gt;. To still have abstract methods for adding requests and notifications, a BatchRequestBuilder SHOULD be added. 
      </t>

      <sourcecode>
interface BatchRequestBuilder {
  fun addRequest(
      method: String,
      parameters: JsonElement? = null,
      id: JsonPrimitive? = null
  )

  fun addNotification(
      method: String,
      parameters: JsonElement? = null
  )
}
      </sourcecode>

      <t>TODO</t>
    </section>

    <section title="Backward Compatibility" anchor="compatibility">
      <t>
        In JSON-RPC 1.0, the property jsonrpc is not defined and therefore not mandatory. To accommodate this, the jsonrpc property SHOULD be nullable. This allows the client and server to set it to null.
      </t>

      <t>
        The JSON-RPC 1.0 also only allows parameters to be passed by position. Therefore, the client SHOULD validate the parameter type upon calling a method to ensure this.
      </t>
    </section>

    <section title="Alternatives Considered" anchor="alternatives">

      <section title="Request Parameter Type" anchor="request-parameter-type">
        <t>
          It was considered to represent request parameters using two properties, depending on whether they were passed by position or by name. This would have been represented by a Map&lt;String, JsonObject&gt; for named parameters and a List&lt;JsonObject&gt; for positional parameters. But the need for a kotlinx.serialization class still remains, and thus the class JsonElement is used, which already summarizes these possibilities.
        </t>
      </section>

      <section title="Notification Handling" anchor="notification-handling">
        <t>
          The idea of using a separate data class for notifications was considered.
        </t>

        <sourcecode type="kotlin">
data class JsonRpcNotification (
    override val jsonrpc: String,
    val method: String,
    val params: JsonElement? = null
) : JsonRpcObject
        </sourcecode>

        <t>

          This would allow stricter type handling in the later design of the API. However, this also complicates the case of batch requests, as they may include both requests and notifications within a single array.

        </t>

        <t>
          Ultimately, this idea was tossed due to the limited benefits. This results in additional validation that needs to be added later on, but since validation is required anyway, this approach mainly introduces additional complexity.
        </t>
      </section>

      <section title="Client Method Parameters" anchor="client-method-parameters">
        <t>

          An alternative design was considered where client API methods accept a single JsonRpcRequest object rather than individual parameters. This would allow the request and notify methods to share a common signature, giving callers more flexibility in how requests are constructed.

        </t>

        <t>
          However, exposing JsonRpcRequest at the API boundary would require users to work directly with protocol-level details, such as assigning request identifiers and specifying the protocol version. This increases the risk of constructing invalid messages and necessitates additional validations. 
        </t>

        <t>
          To avoid exposing protocol-specific properties such as jsonrpc and id, and to prevent invalid states by construction, the client API instead accepts method names and parameters directly.
        </t>
      </section>
    </section>
  </middle>

  <back>
    <references title="References">
      <reference anchor="JSON-RPC-2.0">
        <front>
          <title>JSON-RPC 2.0 Specification</title>
          <author fullname="JSON-RPC Working Group"/>
          <date year="2010"/>
        </front>
        <seriesInfo name="URL" value="https://www.jsonrpc.org/specification"/>
      </reference>
    </references>
  </back>
</rfc>